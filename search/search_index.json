{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MCHEP","text":"<p>MCHEP is a highly parallelizable Monte Carlo integration routine. Specifically, it supports multi-threads/cores parallelization, Single Instruction Multiple Data (SIMD) instructions, and GPU acceleration. Currently, it implements two adaptive multidimensional integrations, namely VEGAS and VEGAS+ (with adaptive stratified sampling) as presented in the paper arXiv:2009.05112.</p>"},{"location":"#performance","title":"Performance","text":"<p>The following benchmark compares MCHEP against the CUBA library across different integrand complexities, simulating typical High Energy Physics (HEP) workloads:</p> <p></p> <p>Left plot: Integration throughput (evaluations per millisecond) vs. computational cost per evaluation. MCHEP with SIMD+AVX consistently outperforms both MCHEP scalar and CUBA across all complexity levels.</p> <p>Right plot: Speedup factor of MCHEP implementations compared to CUBA Vegas. MCHEP SIMD+AVX achieves 4-6x speedup over CUBA for typical HEP workloads.</p> QCD Complexity Typical Cost (FLOPS) MCHEP Scalar (evals/ms) MCHEP SIMD+AVX (evals/ms) CUBA (evals/ms) Speedup vs CUBA LO ~10k 2,500 7,500 1,800 4.2x NLO ~1M 48 153 34 4.5x NNLO ~10M 5 18 5 3.9x <p>Combined with multi-core parallelization (16 cores), MCHEP can reduce month-long calculations to days.</p>"},{"location":"#feature-availability","title":"Feature Availability","text":"Feature Rust API (Vegas) Rust API (Vegas+) C/C++ API (Vegas) C/C++ API (Vegas+) Python API (Vegas) Python API (Vegas+) Multi-threaded \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 SIMD \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 GPU \u2713 \u2713 MPI \u2713 \u2713 \u2713 MPI+SIMD \u2713 \u2713"},{"location":"SIMD_TUTORIAL/","title":"SIMD Integration Tutorial for MCHEP C/C++ API","text":"<p>This tutorial explains how to use MCHEP's SIMD (Single Instruction Multiple Data) integration capability to accelerate Monte Carlo integration in C/C++ applications.</p>"},{"location":"SIMD_TUTORIAL/#overview","title":"Overview","text":"<p>MCHEP's SIMD integration evaluates 4 integration points simultaneously, which can significantly improve performance by relying on a better CPU cache utilization, enabling compiler auto-vectorization, and reducing function call overhead.</p>"},{"location":"SIMD_TUTORIAL/#quick-start","title":"Quick Start","text":"<p>Here's a minimal example that integrates a 2D Gaussian:</p> <pre><code>#include &lt;mchep.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n#include &lt;cmath&gt;\n\n// SIMD integrand: evaluates 4 points at once\nstd::array&lt;double, 4&gt; gaussian_simd(const std::vector&lt;double&gt;&amp; x) {\n    std::array&lt;double, 4&gt; results;\n    const int dim = 2;\n    const int simd_width = 4;\n\n    for (int i = 0; i &lt; simd_width; ++i) {\n        double sum = 0.0;\n        for (int d = 0; d &lt; dim; ++d) {\n            double val = x[d * simd_width + i];  // Note the memory layout!\n            sum += val * val;\n        }\n        results[i] = std::exp(-sum);\n    }\n    return results;\n}\n\nint main() {\n    // Integration boundaries: [0, 1] x [0, 1]\n    std::vector&lt;std::pair&lt;double, double&gt;&gt; boundaries = {\n        {0.0, 1.0},\n        {0.0, 1.0}\n    };\n\n    // Create integrator: 10 iterations, 100k evals/iter, 50 bins, alpha=1.5\n    mchep::Vegas vegas(10, 100000, 50, 1.5, boundaries);\n\n    // Run SIMD integration\n    VegasResult result = vegas.integrate_simd(gaussian_simd);\n\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; result.value &lt;&lt; \" +/- \" &lt;&lt; result.error &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Compile with: <pre><code>c++ -std=c++11 -O3 example.cpp $(pkg-config --cflags --libs mchep_capi) -o example\n</code></pre></p>"},{"location":"SIMD_TUTORIAL/#understanding-the-simd-memory-layout","title":"Understanding the SIMD Memory Layout","text":"<p>The key difference between scalar and SIMD integration is the memory layout of input points.</p>"},{"location":"SIMD_TUTORIAL/#scalar-layout-array-of-structures-aos","title":"Scalar Layout (Array of Structures - AoS)","text":"<pre><code>Point 0: [x0, y0, z0]\nPoint 1: [x1, y1, z1]\nPoint 2: [x2, y2, z2]\nPoint 3: [x3, y3, z3]\n</code></pre>"},{"location":"SIMD_TUTORIAL/#simd-layout-structure-of-arrays-soa","title":"SIMD Layout (Structure of Arrays - SoA)","text":"<pre><code>[x0, x1, x2, x3, y0, y1, y2, y3, z0, z1, z2, z3]\n|--------------||--------------||--------------|\n  dimension 0     dimension 1     dimension 2\n</code></pre> <p>The formula to access coordinate <code>d</code> of point <code>i</code> is then: <pre><code>x[d * simd_width + i]  // where simd_width = 4\n</code></pre></p>"},{"location":"SIMD_TUTORIAL/#visual-example-3d-4-points","title":"Visual Example (3D, 4 points)","text":"<pre><code>Input vector x (size = dim * 4 = 12):\n\nIndex:  0    1    2    3    4    5    6    7    8    9   10   11\n      [x0 , x1 , x2 , x3 , y0 , y1 , y2 , y3 , z0 , z1 , z2 , z3]\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            dim 0              dim 1               dim 2\n\nTo get point i's coordinates:\n  Point 0: x[0], x[4], x[8]  \u2192 (x0, y0, z0)\n  Point 1: x[1], x[5], x[9]  \u2192 (x1, y1, z1)\n  Point 2: x[2], x[6], x[10] \u2192 (x2, y2, z2)\n  Point 3: x[3], x[7], x[11] \u2192 (x3, y3, z3)\n</code></pre>"},{"location":"SIMD_TUTORIAL/#complete-example-physics-integrand","title":"Complete Example: Physics Integrand","text":"<p>Here's a more realistic example, computing a phase space integral:</p> <pre><code>#include &lt;mchep.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n#include &lt;cmath&gt;\n\n// Physical constants\nconstexpr double PI = 3.14159265358979323846;\nconstexpr double MASS = 1.0;\n\n// SIMD integrand for a 4D phase space integral\n// Integrates: exp(-E) * sin(theta) over [0,inf) x [0,pi] x [0,2pi] x [0,inf)\nstd::array&lt;double, 4&gt; phase_space_simd(const std::vector&lt;double&gt;&amp; x) {\n    std::array&lt;double, 4&gt; results;\n    constexpr int dim = 4;\n    constexpr int simd_width = 4;\n\n    for (int i = 0; i &lt; simd_width; ++i) {\n        // Extract coordinates for point i\n        double p     = x[0 * simd_width + i];  // momentum magnitude [0, 10]\n        double theta = x[1 * simd_width + i];  // polar angle [0, pi]\n        double phi   = x[2 * simd_width + i];  // azimuthal angle [0, 2pi]\n        double E     = x[3 * simd_width + i];  // energy [0, 10]\n\n        // Phase space element with Boltzmann suppression\n        double jacobian = p * p * std::sin(theta);\n        double boltzmann = std::exp(-E);\n\n        results[i] = jacobian * boltzmann;\n    }\n    return results;\n}\n\nint main() {\n    // 4D integration boundaries\n    std::vector&lt;std::pair&lt;double, double&gt;&gt; boundaries = {\n        { 0.0, 10.0 },    // p: momentum\n        { 0.0, PI   },    // theta: polar angle\n        { 0.0, 2*PI },    // phi: azimuthal angle\n        { 0.0, 10.0 }     // E: energy\n    };\n\n    // Create Vegas integrator\n    mchep::Vegas vegas(\n        20,       // iterations\n        200000,   // evaluations per iteration\n        50,       // grid bins\n        1.5,      // alpha (grid adaptation speed)\n        boundaries\n    );\n\n    // Set seed for reproducibility\n    vegas.set_seed(42);\n\n    // Integrate with 0.5% target accuracy\n    VegasResult result = vegas.integrate_simd(phase_space_simd, 0.5);\n\n    std::cout &lt;&lt; \"Phase space integral:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"  Value: \" &lt;&lt; result.value &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"  Error: \" &lt;&lt; result.error &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"  Relative error: \" &lt;&lt; (result.error/result.value)*100 &lt;&lt; \"%\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"  Chi2/dof: \" &lt;&lt; result.chi2_dof &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"SIMD_TUTORIAL/#converting-scalar-to-simd-integrand","title":"Converting Scalar to SIMD Integrand","text":"<p>If you have an existing scalar integrand:</p> <pre><code>// Scalar version\ndouble my_integrand(const std::vector&lt;double&gt;&amp; x) {\n    double result = 0.0;\n    for (size_t d = 0; d &lt; x.size(); ++d) {\n        result += x[d] * x[d];\n    }\n    return std::exp(-result);\n}\n</code></pre> <p>Convert it to SIMD by: (a) changing the return type to <code>std::array&lt;double, 4&gt;</code>, (b) adding an outer loop over 4 points, and (c) changing the index from <code>x[d]</code> to <code>x[d * 4 + i]</code>.</p> <pre><code>// SIMD version\nstd::array&lt;double, 4&gt; my_integrand_simd(const std::vector&lt;double&gt;&amp; x) {\n    std::array&lt;double, 4&gt; results;\n    const int dim = x.size() / 4;  // Total size is dim * 4\n\n    for (int i = 0; i &lt; 4; ++i) {           // Loop over 4 points\n        double sum = 0.0;\n        for (int d = 0; d &lt; dim; ++d) {\n            double val = x[d * 4 + i];       // Changed indexing\n            sum += val * val;\n        }\n        results[i] = std::exp(-sum);\n    }\n    return results;\n}\n</code></pre>"},{"location":"SIMD_TUTORIAL/#using-vegas-with-simd","title":"Using VEGAS\\(+\\) with SIMD","text":"<p>Vegas\\(+\\) adds adaptive stratified sampling on top of Vegas, which can improve convergence for integrands with localized peaks. It also supports SIMD integration.</p>"},{"location":"SIMD_TUTORIAL/#vegas-parameters","title":"Vegas\\(+\\) Parameters","text":"<p>VegasPlus has two additional parameters compared to Vegas: <code>n_strat</code>: which represents the number of stratifications per dimension (<code>total hypercubes = n_strat^dim</code>) and <code>beta</code> which represents the stratification adaptation parameter (typically <code>0.5-0.75</code>).</p>"},{"location":"SIMD_TUTORIAL/#example","title":"Example","text":"<pre><code>#include &lt;mchep.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n#include &lt;cmath&gt;\n\nstd::array&lt;double, 4&gt; peaked_integrand_simd(const std::vector&lt;double&gt;&amp; x) {\n    std::array&lt;double, 4&gt; results;\n    const int dim = 4;\n    const int simd_width = 4;\n\n    for (int i = 0; i &lt; simd_width; ++i) {\n        double dx2 = 0.0;\n        for (int d = 0; d &lt; dim; ++d) {\n            double val = x[d * simd_width + i];\n            double diff = val - 0.5;\n            dx2 += diff * diff;\n        }\n        // Narrow Gaussian peak at center\n        results[i] = std::exp(-100.0 * dx2) * 1013.2118364296088;\n    }\n    return results;\n}\n\nint main() {\n    std::vector&lt;std::pair&lt;double, double&gt;&gt; boundaries = {\n        {0.0, 1.0}, {0.0, 1.0}, {0.0, 1.0}, {0.0, 1.0}\n    };\n\n    // Create VegasPlus integrator\n    mchep::VegasPlus vegasplus(\n        10,       // n_iter: iterations\n        100000,   // n_eval: evaluations per iteration\n        50,       // n_bins: grid bins\n        1.5,      // alpha: grid adaptation\n        2,        // n_strat: stratifications per dimension (2^4 = 16 hypercubes)\n        0.75,     // beta: stratification adaptation\n        boundaries\n    );\n\n    vegasplus.set_seed(1234);\n\n    // Run SIMD integration\n    VegasResult result = vegasplus.integrate_simd(peaked_integrand_simd, -1.0);\n\n    std::cout &lt;&lt; \"VegasPlus SIMD Result: \" &lt;&lt; result.value\n              &lt;&lt; \" +/- \" &lt;&lt; result.error &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"SIMD_TUTORIAL/#when-to-use-vegas","title":"When to Use VEGAS\\(+\\)","text":"Integrand Type Recommended Smooth, no peaks Vegas Single localized peak Vegas\\(+\\) Multiple peaks Vegas\\(+\\) with higher <code>n_strat</code> Very high dimensions (&gt;6) Vegas (stratification overhead grows as <code>n_strat^dim</code>)"},{"location":"SIMD_TUTORIAL/#performance-comparison","title":"Performance Comparison","text":"<p>For a narrow Gaussian in 4D (1M evaluations):</p> Method Time Result Vegas SIMD 39 ms 0.99952 \u00b1 0.00064 Vegas\\(+\\) SIMD 37 ms 1.00017 \u00b1 0.00062 <p>Vegas\\(+\\) achieves slightly better precision for peaked integrands.</p>"},{"location":"SIMD_TUTORIAL/#using-the-c-api-directly","title":"Using the C API Directly","text":"<p>If you prefer the C API over the C++ wrapper:</p> <pre><code>#include &lt;mchep_capi.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\n// C-style SIMD integrand\nvoid my_simd_integrand(const double* x, int dim, void* user_data, double* result) {\n    for (int i = 0; i &lt; 4; ++i) {\n        double sum = 0.0;\n        for (int d = 0; d &lt; dim; ++d) {\n            double val = x[d * 4 + i];\n            sum += val * val;\n        }\n        result[i] = exp(-sum);\n    }\n}\n\nint main() {\n    CBoundary boundaries[] = {{0.0, 1.0}, {0.0, 1.0}};\n\n    VegasC* vegas = mchep_vegas_new(10, 100000, 50, 1.5, 2, boundaries);\n    mchep_vegas_set_seed(vegas, 1234);\n\n    VegasResult result = mchep_vegas_integrate_simd(\n        vegas,\n        my_simd_integrand,\n        NULL,   // user_data (optional)\n        -1.0    // target_accuracy (-1 = disabled)\n    );\n\n    printf(\"Result: %f +/- %f\\n\", result.value, result.error);\n\n    mchep_vegas_free(vegas);\n    return 0;\n}\n</code></pre>"},{"location":"SIMD_TUTORIAL/#performance-tips","title":"Performance Tips","text":""},{"location":"SIMD_TUTORIAL/#1-enable-compiler-optimizations","title":"1. Enable Compiler Optimizations","text":"<pre><code>c++ -O3 -march=native -ffast-math example.cpp ...\n</code></pre>"},{"location":"SIMD_TUTORIAL/#2-minimize-branching-inside-the-loop","title":"2. Minimize Branching Inside the Loop","text":"<p>Bad: <pre><code>for (int i = 0; i &lt; 4; ++i) {\n    if (x[i] &gt; 0.5) {  // Branch inside loop - bad for SIMD\n        results[i] = func1(x[i]);\n    } else {\n        results[i] = func2(x[i]);\n    }\n}\n</code></pre></p> <p>Better: <pre><code>for (int i = 0; i &lt; 4; ++i) {\n    // Branchless: compute both, blend result\n    double v1 = func1(x[d * 4 + i]);\n    double v2 = func2(x[d * 4 + i]);\n    double t = (x[d * 4 + i] &gt; 0.5) ? 1.0 : 0.0;\n    results[i] = t * v1 + (1.0 - t) * v2;\n}\n</code></pre></p>"},{"location":"SIMD_TUTORIAL/#3-use-explicit-simd-intrinsics-advanced","title":"3. Use Explicit SIMD Intrinsics (Advanced)","text":"<p>For maximum performance, use CPU intrinsics:</p> <pre><code>#include &lt;immintrin.h&gt;  // AVX\n\nstd::array&lt;double, 4&gt; gaussian_avx(const std::vector&lt;double&gt;&amp; x) {\n    std::array&lt;double, 4&gt; results;\n    const int dim = x.size() / 4;\n\n    __m256d sum = _mm256_setzero_pd();\n\n    for (int d = 0; d &lt; dim; ++d) {\n        __m256d val = _mm256_loadu_pd(&amp;x[d * 4]);\n        sum = _mm256_fmadd_pd(val, val, sum);  // sum += val * val\n    }\n\n    // exp(-sum) - need to extract and compute\n    _mm256_storeu_pd(results.data(), sum);\n    for (int i = 0; i &lt; 4; ++i) {\n        results[i] = std::exp(-results[i]);\n    }\n\n    return results;\n}\n</code></pre> <p>For a complete heavy HEP-style example with 1000 FMA operations achieving 2-2.5x speedup, see benchmark_simd_avx.cpp.</p>"},{"location":"SIMD_TUTORIAL/#api-reference","title":"API Reference","text":""},{"location":"SIMD_TUTORIAL/#c-api","title":"C++ API","text":"<pre><code>// Create Vegas integrator\nmchep::Vegas vegas(n_iter, n_eval, n_bins, alpha, boundaries);\n\n// Create VegasPlus integrator (with stratified sampling)\nmchep::VegasPlus vegasplus(n_iter, n_eval, n_bins, alpha, n_strat, beta, boundaries);\n\n// SIMD integration (same for both Vegas and VegasPlus)\nVegasResult result = vegas.integrate_simd(integrand_func, target_accuracy);\nVegasResult result = vegasplus.integrate_simd(integrand_func, target_accuracy);\n\n// Result structure\nstruct VegasResult {\n    double value;     // Estimated integral\n    double error;     // Statistical error (1 sigma)\n    double chi2_dof;  // Chi-squared per degree of freedom\n};\n</code></pre>"},{"location":"SIMD_TUTORIAL/#c-api_1","title":"C API","text":"<pre><code>// SIMD integrand signature\ntypedef void (*CSimdIntegrand)(const double* x, int dim, void* user_data, double* result);\n\n// Vegas SIMD integration\nVegasC* mchep_vegas_new(n_iter, n_eval, n_bins, alpha, dim, boundaries);\nVegasResult mchep_vegas_integrate_simd(vegas, integrand, user_data, target_accuracy);\nvoid mchep_vegas_free(vegas);\n\n// VegasPlus SIMD integration\nVegasPlusC* mchep_vegas_plus_new(n_iter, n_eval, n_bins, alpha, n_strat, beta, dim, boundaries);\nVegasResult mchep_vegas_plus_integrate_simd(vegasplus, integrand, user_data, target_accuracy);\nvoid mchep_vegas_plus_free(vegasplus);\n</code></pre>"},{"location":"building/","title":"Building and Installation","text":"<p>This page guides you through the process of installing MCHEP and its dependencies for different environments.</p>"},{"location":"building/#rust-api","title":"Rust API","text":"DefaultDevelopment <p>Add <code>mchep</code> to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nmchep = { version = \"0.1.0\", features = [\"simd\"] }\n</code></pre> <p>Clone the repository and build it by running the following command:</p> <pre><code>cargo build --features \"mpi gpu\"\n</code></pre> <p>You can also include it in your project by passing the path to the cloned repository:</p> <pre><code>[dependencies]\nmchep = { path = \"./path/to/mchep\", features = [\"simd\"] }\n</code></pre> <p>MCHEP provides several optional features such as <code>mpi</code> to enable distributed integration using MPI, <code>gpu</code> to enable GPU acceleration using the Burn framework, and <code>simd</code> to enable SIMD-optimized routines (enabled by default).</p>"},{"location":"building/#cc-api","title":"C/C++ API","text":"<p>The C/C++ API can be installed using a pre-built binary script or built from source.</p> DefaultDevelopment <p>Use the provided installation script to download and install the latest pre-built binaries:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/QCDLab/mchep/refs/heads/master/install-capi.sh | sh\n</code></pre> <p>To pass the installation directory for where to put the files, change the arguments of the shell as follows:</p> <pre><code>.. | sh -s -- --prefix /custom/installation/path\n</code></pre> <p>By default, the script will download the latest stable release. If you would like a specific version, pass the version along with <code>--version</code>:</p> <pre><code>.. | sh -s -- --version 0.1.0\n</code></pre> <p>This script automatically detects your platform, downloads the correct tarball from GitHub, and configures the <code>pkg-config</code> files.</p> <p>To build from source, you need <code>cargo</code> and <code>cargo-c</code>:</p> <pre><code>cargo install cargo-c\n\n# Define the installation prefix\nexport CARGO_C_MCHEP_INSTALL_PREFIX=/usr/local\n\n# Install the library and headers\ncargo cinstall --release --prefix=$CARGO_C_MCHEP_INSTALL_PREFIX --manifest-path mchep_capi/Cargo.toml\n</code></pre>"},{"location":"building/#environment-configuration","title":"Environment Configuration","text":"<p>After installation, make sure your environment variables are set:</p> <pre><code>export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH\nexport PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH\n</code></pre> <p>Verify the installation: <pre><code>pkg-config mchep_capi --libs --cflags\n</code></pre></p>"},{"location":"building/#python-api","title":"Python API","text":"DefaultDevelopment <p>Install the latest version from PyPI:</p> <pre><code>pip install mchep\n</code></pre> <p>To build the Python extension from source, you need <code>maturin</code>:</p> <pre><code>cd mchep_pyapi\nmaturin develop\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This section provides practical examples of how to use MCHEP for multi-dimensional integration. MCHEP supports both Rust, C/C++, and Python APIs, and offers various acceleration features like multi-threading, SIMD, GPU, and MPI.</p>"},{"location":"tutorials/#basic-integration-vegas","title":"Basic Integration (VEGAS)","text":"<p>The VEGAS algorithm uses adaptive importance sampling to focus evaluations in regions where the integrand is largest.</p>  Rust C++ Python <pre><code>use mchep::vegas::{Vegas, VegasResult};\nuse mchep::integrand::Integrand;\n\n// Define your integrand\nstruct Gaussian;\n\nimpl Integrand for Gaussian {\n    fn dim(&amp;self) -&gt; usize { 2 }\n    fn eval(&amp;self, x: &amp;[f64]) -&gt; f64 {\n        let r2 = x[0]*x[0] + x[1]*x[1];\n        (-r2).exp()\n    }\n}\n\nfn main() {\n    let boundaries = &amp;[(0.0, 1.0), (0.0, 1.0)];\n    let mut vegas = Vegas::new(10, 100_000, 50, 1.5, boundaries);\n\n    let result = vegas.integrate(&amp;Gaussian, None);\n    println!(\"Result: {} +/- {}\", result.value, result.error);\n}\n</code></pre> <pre><code>#include &lt;mchep.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nint main() {\n    std::vector&lt;std::pair&lt;double, double&gt;&gt; boundaries = {\n        {0.0, 1.0}, {0.0, 1.0}\n    };\n\n    mchep::Vegas vegas(10, 100000, 50, 1.5, boundaries);\n\n    auto integrand = [](const std::vector&lt;double&gt;&amp; x) {\n        double r2 = x[0]*x[0] + x[1]*x[1];\n        return std::exp(-r2);\n    };\n\n    VegasResult result = vegas.integrate(integrand);\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; result.value &lt;&lt; \" +/- \" &lt;&lt; result.error &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <pre><code>import math\nfrom mchep.vegas import Vegas\n\ndef gaussian(x):\n    r2 = x[0]**2 + x[1]**2\n    return math.exp(-r2)\n\nboundaries = [(0.0, 1.0), (0.0, 1.0)]\nvegas = Vegas(10, 100000, 50, 1.5, boundaries)\n\nresult = vegas.integrate(gaussian)\nprint(f\"Result: {result.value} +/- {result.error}\")\n</code></pre>"},{"location":"tutorials/#adaptive-stratified-sampling-vegas","title":"Adaptive Stratified Sampling (VEGAS\\(+\\))","text":"<p>VEGAS+ adds adaptive stratified sampling, which is particularly effective for integrands with multiple or sharp peaks.</p>  Rust C++ Python <pre><code>use mchep::vegasplus::VegasPlus;\nuse mchep::integrand::Integrand;\n\nstruct PeakedIntegrand;\nimpl Integrand for PeakedIntegrand {\n    fn dim(&amp;self) -&gt; usize { 2 }\n    fn eval(&amp;self, x: &amp;[f64]) -&gt; f64 {\n        // A sharp peak at (0.5, 0.5)\n        let d2 = (x[0]-0.5).powi(2) + (x[1]-0.5).powi(2);\n        (-100.0 * d2).exp()\n    }\n}\n\nfn main() {\n    let boundaries = &amp;[(0.0, 1.0), (0.0, 1.0)];\n    // Params: n_iter, n_eval, n_bins, alpha, n_strat, beta, boundaries\n    let mut vp = VegasPlus::new(10, 100_000, 50, 1.5, 4, 0.75, boundaries);\n\n    let result = vp.integrate(&amp;PeakedIntegrand, None);\n    println!(\"Result: {} +/- {}\", result.value, result.error);\n}\n</code></pre> <pre><code>#include &lt;mchep.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nint main() {\n    std::vector&lt;std::pair&lt;double, double&gt;&gt; boundaries = {\n        {0.0, 1.0}, {0.0, 1.0}\n    };\n\n    // Params: n_iter, n_eval, n_bins, alpha, n_strat, beta, boundaries\n    mchep::VegasPlus vp(10, 100000, 50, 1.5, 4, 0.75, boundaries);\n\n    auto integrand = [](const std::vector&lt;double&gt;&amp; x) {\n        double d2 = std::pow(x[0]-0.5, 2) + std::pow(x[1]-0.5, 2);\n        return std::exp(-100.0 * d2);\n    };\n\n    VegasResult result = vp.integrate(integrand);\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; result.value &lt;&lt; \" +/- \" &lt;&lt; result.error &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <pre><code>import math\nfrom mchep.vegas import VegasPlus\n\ndef peaked(x):\n    d2 = (x[0]-0.5)**2 + (x[1]-0.5)**2\n    return math.exp(-100.0 * d2)\n\nboundaries = [(0.0, 1.0), (0.0, 1.0)]\n# Params: n_iter, n_eval, n_bins, alpha, n_strat, beta, boundaries\nvp = VegasPlus(10, 100000, 50, 1.5, 4, 0.75, boundaries)\n\nresult = vp.integrate(peaked)\nprint(f\"Result: {result.value} +/- {result.error}\")\n</code></pre>"},{"location":"tutorials/#integration-with-target-accuracy","title":"Integration with Target Accuracy","text":"<p>Instead of running for a fixed number of iterations, you can specify a target accuracy (in percent). The integrator will stop as soon as the estimated relative error falls below this threshold.</p>  Rust C++ Python <pre><code>use mchep::vegas::Vegas;\nuse mchep::integrand::Integrand;\n\nfn main() {\n    let boundaries = &amp;[(0.0, 1.0), (0.0, 1.0)];\n    let mut vegas = Vegas::new(100, 100_000, 50, 1.5, boundaries);\n\n    // Stop when relative error is below 0.1%\n    let target_accuracy = Some(0.1);\n    let result = vegas.integrate(&amp;MyIntegrand, target_accuracy);\n\n    println!(\"Final Accuracy: {}%\", (result.error / result.value) * 100.0);\n}\n</code></pre> <pre><code>#include &lt;mchep.hpp&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::vector&lt;std::pair&lt;double, double&gt;&gt; boundaries = {{0.0, 1.0}, {0.0, 1.0}};\n    mchep::Vegas vegas(100, 100000, 50, 1.5, boundaries);\n\n    // Stop when relative error is below 0.1%\n    double target_accuracy = 0.1;\n    VegasResult result = vegas.integrate(my_integrand, target_accuracy);\n\n    std::cout &lt;&lt; \"Final Accuracy: \" &lt;&lt; (result.error / result.value) * 100.0 &lt;&lt; \"%\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <pre><code>from mchep.vegas import Vegas\n\nboundaries = [(0.0, 1.0), (0.0, 1.0)]\nvegas = Vegas(100, 100000, 50, 1.5, boundaries)\n\n# Stop when relative error is below 0.1%\ntarget_accuracy = 0.1\nresult = vegas.integrate(my_integrand, target_accuracy=target_accuracy)\n\nprint(f\"Final Accuracy: {(result.error / result.value) * 100.0}%\")\n</code></pre>"},{"location":"tutorials/#simd-acceleration","title":"SIMD Acceleration","text":"<p>SIMD (Single Instruction Multiple Data) allows evaluating multiple points simultaneously (typically 4 for <code>f64x4</code>). This provides significant speedups for compute-heavy integrands.</p>  Rust C++ Python <pre><code>use mchep::vegas::Vegas;\nuse mchep::integrand::SimdIntegrand;\nuse wide::f64x4;\n\nstruct SimdGaussian;\n\nimpl SimdIntegrand for SimdGaussian {\n    fn dim(&amp;self) -&gt; usize { 2 }\n    fn eval_simd(&amp;self, points: &amp;[f64x4]) -&gt; f64x4 {\n        let x = points[0];\n        let y = points[1];\n        let r2 = x*x + y*y;\n        (-r2).exp() // wide::f64x4 implements .exp()\n    }\n}\n\nfn main() {\n    let boundaries = &amp;[(0.0, 1.0), (0.0, 1.0)];\n    let mut vegas = Vegas::new(10, 100_000, 50, 1.5, boundaries);\n\n    let result = vegas.integrate_simd(&amp;SimdGaussian, None);\n    println!(\"SIMD Result: {} +/- {}\", result.value, result.error);\n}\n</code></pre> <pre><code>#include &lt;mchep.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;array&gt;\n#include &lt;cmath&gt;\n\nint main() {\n    std::vector&lt;std::pair&lt;double, double&gt;&gt; boundaries = {{0.0, 1.0}, {0.0, 1.0}};\n    mchep::Vegas vegas(10, 100000, 50, 1.5, boundaries);\n\n    // x vector size is dim * 4 (SoA layout)\n    auto simd_integrand = [](const std::vector&lt;double&gt;&amp; x) {\n        std::array&lt;double, 4&gt; results;\n        for (int i = 0; i &lt; 4; ++i) {\n            double r2 = x[0*4 + i]*x[0*4 + i] + x[1*4 + i]*x[1*4 + i];\n            results[i] = std::exp(-r2);\n        }\n        return results;\n    };\n\n    VegasResult result = vegas.integrate_simd(simd_integrand);\n    std::cout &lt;&lt; \"SIMD Result: \" &lt;&lt; result.value &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <pre><code>import math\nfrom mchep.vegas import Vegas\n\ndef gaussian_simd(x_soa):\n    # x_soa is a list of lists: [ [x0,x1,x2,x3], [y0,y1,y2,y3], ... ]\n    results = [0.0] * 4\n    for i in range(4):\n        r2 = x_soa[0][i]**2 + x_soa[1][i]**2\n        results[i] = math.exp(-r2)\n    return results\n\nboundaries = [(0.0, 1.0), (0.0, 1.0)]\nvegas = Vegas(10, 100000, 50, 1.5, boundaries)\n\nresult = vegas.integrate_simd(gaussian_simd)\nprint(f\"SIMD Result: {result.value}\")\n</code></pre>"},{"location":"tutorials/#gpu-acceleration","title":"GPU Acceleration","text":"<p>MCHEP supports GPU integration in Rust using the <code>Burn</code> deep learning framework. This allows you to leverage the massive parallelism of modern GPUs for evaluation-heavy integrands.</p>  Rust C++ Python <pre><code>// Requires \"gpu\" feature enabled\nuse mchep::vegas::Vegas;\nuse mchep::integrand::BurnIntegrand;\nuse burn::prelude::*;\n\nstruct GpuGaussian;\n\nimpl&lt;B: Backend&gt; BurnIntegrand&lt;B&gt; for GpuGaussian {\n    fn dim(&amp;self) -&gt; usize { 2 }\n\n    fn eval_burn(&amp;self, points: Tensor&lt;B, 2&gt;) -&gt; Tensor&lt;B, 1&gt; {\n        // points shape: [n_points, dim]\n        let x = points.clone().slice([0..points.dims()[0], 0..1]);\n        let y = points.clone().slice([0..points.dims()[0], 1..2]);\n\n        let x2 = x.clone() * x;\n        let y2 = y.clone() * y;\n\n        let neg_r2 = (x2 + y2).mul_scalar(-1.0);\n        neg_r2.exp().squeeze(1)\n    }\n}\n\nfn main() {\n    let boundaries = &amp;[(-1.0, 1.0), (-1.0, 1.0)];\n    let mut vegas = Vegas::new(10, 100_000, 50, 0.5, boundaries);\n\n    // integrate_gpu automatically initializes the WGPU backend\n    let result = vegas.integrate_gpu(&amp;GpuGaussian, None);\n    println!(\"GPU Result: {} +/- {}\", result.value, result.error);\n}\n</code></pre> <p>GPU integration is currently only supported via the Rust API.</p> <p>GPU integration is currently only supported via the Rust API.</p>"},{"location":"tutorials/#distributed-integration-mpi","title":"Distributed Integration (MPI)","text":"<p>For very large integration tasks, MCHEP can be distributed across multiple nodes using Message Passing Interface (MPI).</p>  Rust C++ Python <pre><code>// Requires \"mpi\" feature enabled\nuse mchep::vegasplus::VegasPlus;\nuse mchep::integrand::Integrand;\nuse mpi::traits::*;\n\nfn main() {\n    let universe = mpi::initialize().unwrap();\n    let world = universe.world();\n    let rank = world.rank();\n\n    let boundaries = &amp;[(0.0, 1.0), (0.0, 1.0)];\n    let mut vp = VegasPlus::new(10, 100_000, 50, 1.5, 4, 0.75, boundaries);\n\n    // integrate_mpi distributes evaluations across the MPI communicator\n    let result = vp.integrate_mpi(&amp;MyIntegrand, &amp;world, None);\n\n    if rank == 0 {\n        println!(\"MPI Result: {} +/- {}\", result.value, result.error);\n    }\n}\n</code></pre> <pre><code>#include &lt;mchep.hpp&gt;\n#include &lt;mpi.h&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char** argv) {\n    MPI_Init(&amp;argc, &amp;argv);\n    int rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);\n\n    std::vector&lt;std::pair&lt;double, double&gt;&gt; boundaries = {{0.0, 1.0}, {0.0, 1.0}};\n    mchep::VegasPlus vp(10, 100000, 50, 1.5, 4, 0.75, boundaries);\n\n    auto integrand = [](const std::vector&lt;double&gt;&amp; x) {\n        return std::exp(-(x[0]*x[0] + x[1]*x[1]));\n    };\n\n    // Use integrate_mpi with an MPI communicator\n    VegasResult result = vp.integrate_mpi(integrand, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        std::cout &lt;&lt; \"MPI Result: \" &lt;&lt; result.value &lt;&lt; std::endl;\n    }\n\n    MPI_Finalize();\n    return 0;\n}\n</code></pre> <pre><code># Run with: mpirun -n 4 python script.py\nfrom mchep.vegas import VegasPlus\nimport math\n\ndef gaussian(x):\n    return math.exp(-(x[0]**2 + x[1]**2))\n\nboundaries = [(0.0, 1.0), (0.0, 1.0)]\nvp = VegasPlus(10, 100000, 50, 1.5, 4, 0.75, boundaries)\n\n# integrate_mpi automatically initializes MPI if needed\nresult = vp.integrate_mpi(gaussian)\n\n# Result is returned on rank 0\nif result.value != 0:\n    print(f\"MPI Result: {result.value}\")\n</code></pre>"},{"location":"tutorials/#mpi-simd-acceleration","title":"MPI + SIMD Acceleration","text":"<p>For specific scenarios, combining MPI and SIMD in principle should provide the ultimate performance, distributing vector-optimized evaluations across multiple nodes.</p>  Rust C++ Python <pre><code>// Requires both \"mpi\" and \"simd\" features\nuse mchep::vegasplus::VegasPlus;\nuse mchep::integrand::SimdIntegrand;\nuse mpi::traits::*;\n\nfn main() {\n    let universe = mpi::initialize().unwrap();\n    let world = universe.world();\n    let rank = world.rank();\n\n    let boundaries = &amp;[(0.0, 1.0), (0.0, 1.0)];\n    let mut vp = VegasPlus::new(10, 100_000, 50, 1.5, 4, 0.75, boundaries);\n\n    // integrate_mpi_simd uses both distributed and vector acceleration\n    let result = vp.integrate_mpi_simd(&amp;MySimdIntegrand, &amp;world, None);\n\n    if rank == 0 {\n        println!(\"MPI+SIMD Result: {} +/- {}\", result.value, result.error);\n    }\n}\n</code></pre> <pre><code>#include &lt;mchep.hpp&gt;\n#include &lt;mpi.h&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char** argv) {\n    MPI_Init(&amp;argc, &amp;argv);\n    int rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);\n\n    std::vector&lt;std::pair&lt;double, double&gt;&gt; boundaries = {{0.0, 1.0}, {0.0, 1.0}};\n    mchep::VegasPlus vp(10, 100000, 50, 1.5, 4, 0.75, boundaries);\n\n    auto simd_integrand = [](const std::vector&lt;double&gt;&amp; x) {\n        std::array&lt;double, 4&gt; results;\n        for (int i = 0; i &lt; 4; ++i) {\n            results[i] = std::exp(-(x[0*4+i]*x[0*4+i] + x[1*4+i]*x[1*4+i]));\n        }\n        return results;\n    };\n\n    // Use integrate_mpi_simd\n    VegasResult result = vp.integrate_mpi_simd(simd_integrand, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        std::cout &lt;&lt; \"MPI+SIMD Result: \" &lt;&lt; result.value &lt;&lt; std::endl;\n    }\n\n    MPI_Finalize();\n    return 0;\n}\n</code></pre> <p>MPI+SIMD integration is currently only supported via the Rust and C++ APIs.</p>"}]}